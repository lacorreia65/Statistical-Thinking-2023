---
title: "Meta Analysis - Polls Elections 2022"
author: "Luis Correia"
date: "10/16/2022"
output:
  pdf_document: default
  html_document:
    df_print: paged
  rmarkdown::pdf_document:
    fig_caption: yes
    number_sections: yes
header-includes:
- \usepackage[margin=1in]{geometry} 
- \usepackage{amsmath,amsthm,amssymb,amsfonts}
- \usepackage{relsize}
- \usepackage{lscape}
- \usepackage{enumerate}
- \usepackage{enumitem}
- \usepackage{setspace}
- \usepackage{tikz}
- \usepackage{bm}
- \usepackage{bbm}
- \usepackage[utf8]{inputenc}
- \usepackage{mathtools, nccmath}
- \usepackage{fancyhdr}
- \usepackage{float}
- \usepackage{longtable}
- \usepackage{threeparttable}
- \usepackage[linesnumbered,vlined,ruled,commentsnumbered]{algorithm2e}
- \floatplacement{figure}{H}
- \floatplacement{table}{H}
- \setlength{\parskip}{1em}
- \pagestyle{fancy}
- \fancyhf{}
- \rhead{Polls Review - Meta Analysis}
- \rfoot{Page \thepage}
urlcolor: blue
---

```{r setup, include=FALSE, cache = FALSE}
require("knitr")

## setting working directory
opts_chunk$set(echo = FALSE, warning=FALSE, message = FALSE)

library(ggplot2)
library(tidyverse)
library(bayesplot)
library(dplyr)
library(rstan)
library(meta)
library(gtools)
library(kableExtra)

# The palette with black - Used in Graphs with :
cbp1 <- c("#999999", "#E69F00", "#56B4E9", "#009E73",
          "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
cbp2 <- c("#000000", "#E69F00", "#56B4E9", "#009E73",
          "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
cbp3 <- c("#FFDB6D", "#C4961A", "#F4EDCA", "#D16103", 
          "#C3D7A4", "#52854C", "#4E84C4", "#293352")

# No. of polls - db_poll_wrk %>% group_by(key) %>% summarise() %>% pull() %>% unique() %>% length()
# No. of Institutes - db_poll_wrk %>% group_by(inst) %>% summarise() %>% pull() %>% unique() %>% length()

# Use specific institute
# target_inst = "brasmarket"  
#target_inst = c("brasmarket","parana pesquisas","gerp", "verita")  

inst_bols <- c("6sigma","brasmarket", "equilibrio","gerp","verita","instituto franca", "ideia big data", "parana pesquisas")
inst_lula <- c("atlasintel/internet", "datafolha", "ipec", "ipespe", "fsb", "quaest", "real time big data")
inst_neutral <- c("mda","poderdata", "futura inteligencia", "ranking")

# Use specific institute
target_round = 2

# Adjust Bias
adjust_bias <- FALSE
```

```{r}
pesq_data <- read.csv("data//pesquisa_eleitoral_2022_BRASIL.csv", sep=";", header=TRUE, encoding="latin1")
```
\section{Read data from Pooling Data}

```{r}
pollingdata <- read.csv("CleanedPollingData_Oct25th2022.csv",header=FALSE)
pdata <- tail(as.matrix(pollingdata), -9)
header_pdata <- c("inst", "code", "date", "modo","entrev","pct_lula","pct_bols","y_null")

n <- 1
reg_pdata <- data.frame()
while (n < dim(pdata)[1]){
  inst <- tolower(pdata[n,1])
  code <- pdata[n+1,1]
  date <- as.Date(pdata[n+1,2])
  modo <- pdata[n+2,1]
  entrevistas <- as.integer(pdata[n+3,1])
  pct_lula <- as.numeric(pdata[n+4,1])/100.0
  pct_bols <- as.numeric(pdata[n+5,1])/100.0
  y_null <- as.numeric(pdata[n+6,1])/100.0
  
  reg_pdata = rbind(reg_pdata, data.frame(
    inst = inst,
    regno = code,
    date = date,
    type = modo,
    n = entrevistas,
    Lula = pct_lula,
    Bolsonaro = pct_bols,
    Y_Null = y_null))
  

  n <- n+7
}
db_poll_wrk <- pivot_longer(reg_pdata,cols=Lula:Y_Null,names_to="name", values_to="pct") |> 
  mutate(Me = pct,
         Pe = pct*n,
         Ne = Pe,
         Se = pct*(1-pct)*n,
         Mc = (1-pct),
         Pc = (1-pct)*n,
         Nc = Pc,
         Sc = (1-pct)*pct*n,
         newlbl = ifelse(name=="Y_Null", "Y-Blank/Null", name),
         key=paste0(inst,date),
         y_cat = round(pct*n),
         seqno = 1,
         turno = 2)
remove(reg_pdata, pdata, pollingdata)

# Compatibilize working databases

db_work  <- db_poll_wrk %>% 
  group_by(key, inst, date, newlbl) %>% 
  summarise(y = sum(y_cat)) |> 
  group_by(date, inst) |>
  mutate(pct_val = y/sum(y)) |> 
  ungroup()

paramlbl <- db_work %>% 
  group_by(newlbl) %>%
  summarise() %>% 
  pull(newlbl)
```

```{r}
viespollingdata <- read.csv("ViesPollingData_Oct27th2022.csv",header=FALSE)
viespdata <- tail(as.matrix(viespollingdata), -9)
header_pdata <- c("inst", "code", "date", "modo","entrev","pct_lula","pct_bols","y_null")

n <- 1
db_viespdata <- data.frame()
while (n < dim(viespdata)[1]){
  inst <- tolower(viespdata[n])
  modo <- viespdata[n+1]
  vbols <- as.numeric(viespdata[n+2])
  vlula <- as.numeric(viespdata[n+3])
  vnull <- as.numeric(viespdata[n+4])
  
  db_viespdata = rbind(db_viespdata, data.frame(
    inst = inst,
    type = modo,
    vbols = vbols,
    vlula = vlula,
    vnull = vnull))
  

  n <- n+5
}
remove(viespdata, viespollingdata)

# Apply bias reduction
if (adjust_bias) {
  # Temporary join dataframe
  db_jn <- left_join(db_poll_wrk, db_viespdata)
  
  db_poll_wrk <- db_jn |> 
    group_by(newlbl) |> 
    mutate(pct = ifelse(newlbl=="Bolsonaro",pct-vbols,
                        ifelse(newlbl=="Lula",pct-vlula,
                               ifelse(newlbl=="Y_Blank/Null",pct-vnull,pct))),
           Me = pct,
           Pe = pct*n,
           Ne = Pe,
           Se = pct*(1-pct)*n,
           Mc = (1-pct),
           Pc = (1-pct)*n,
           Nc = Pc,
           Sc = (1-pct)*pct*n,
           y_cat = round(pct*n))
  
  remove(db_jn)
}

```

\section{Read data from PoderData}

```{r}
polldata <- read_csv("polls_vFINAL.csv", show_col_types = FALSE)
# polldata <- read_csv("polls_2018_v0.csv", show_col_types = FALSE)

# Recoding parameters
## We consider the valid candidates 1-(K-1) and 1 category of blank votes

#polldata |> 
#  group_by(name) |> 
#  summarise(n=n())

other_cat <- c("branco / nulo",
               "brancos",
               "nulos",
               "branco / nulo / indeciso",
               "branco / nulo / indeciso / nenhum / nao sabe / nao respondeu",
               "branco / nulo / nao votara",
               "branco / nulo / nenhum",
               "branco / nulo / ninguem / justificar")
undecided_cat <- c("indeciso",
                   "indeciso / nao sabe / nao respondeu",
                   "nao respondeu",
                   "nao sabe",
                   "nao sabe / nao respondeu",
                   "nao sabem",
                   "nenhum",
                   "nenhum / nao sabe / nao respondeu",
                   "Outros")
valid_candidates <- c("Bolsonaro", "Ciro", "Eymael", "Leonardo Pericles", "Luiz Felipe d'Avila",
                      "Lula","Padre Kelmon","Pericles",                                         
                      # "Roberto Jefferson", "Pablo Marcal", 
                      "Simone Tebet", "Sofia Manzano", "Soraya Thronicke", "Vera Lucia", 
                      "Vera Lucia Salgado")

# actual_candidates <- c("Bolsonaro", "Haddad", "Ciro", "Marina", "Alckmin") # 2018

# Threshold To consider relevant candidate
threshold_pct <- .02

db_poll_wrk <- polldata %>% 
  group_by(name) %>% 
  mutate (Me = pct,
          Pe = pct*n,
          Ne = Pe,
          Se = pct*(1-pct)*n,
          Mc = (1-pct),
          Pc = (1-pct)*n,
          Nc = Pc,
          Sc = (1-pct)*pct*n,
          newlbl = ifelse(is.element(name, other_cat), "Y-Blank/Null",
                          ifelse(is.element(name,undecided_cat),"Z-Undec",
                                 ifelse(!is.element(name,valid_candidates), "Y-Blank/Null",
                                        ifelse(pct>threshold_pct, name, "X-Other")))),

          y_cat = round(pct*n))


```

\subsection{Calculate and Adjust bias from results of 1st Round}

Let $$Y_k$$ be the bias from the $$k^{th}$$ institute we can estimate this bias by calculating the difference between the estimate for 1st round and the final results of the elections on October 2nd.

```{r, message=FALSE}
# Calculate bias from 1st round and apply to 2nd round
db_urnas <- db_poll_wrk |> 
  filter(turno==2, inst=="urnas") |> 
  ungroup()

# Select polls from 1st round
db_tmp0.a <- db_poll_wrk |> 
  filter(turno==2, inst!="urnas", pct > 0.0) |> # , newlbl!="Z-Undec"
  select(inst,type,name, newlbl,pct) |> 
  left_join(db_urnas, by="name") |> 
  mutate(error_pct = pct.x-pct.y,
         relerror_pct = error_pct/pct.y,
         ratio_pct = pct.y/pct.x) |>
  filter(newlbl.x != "Y-Blank/Null", newlbl.x != "Z-Undec") |> 
  select(inst.x, type.x, name, newlbl.x,pct.x,pct.y,error_pct,relerror_pct,ratio_pct)

db_tmp0.b <- db_tmp0.a |> 
  group_by(inst.x, type.x) |> 
  mutate(n_inst = n(),
         SD_pct = sd(error_pct),
         MD_pct = sum(abs(error_pct))/n_inst,
         RMSE_pct = sqrt(sum(error_pct^2)/n_inst),
         Dev_lower = MD_pct - qnorm(.975)*SD_pct/sqrt(n_inst),
         Dev_upper = MD_pct + qnorm(.975)*SD_pct/sqrt(n_inst)) |> 
  ungroup()

db_inst <- rbind(data.frame(
  inst.x = inst_lula,
  tend = rep("Lula",length(inst_lula))
),
data.frame(
  inst.x = inst_bols,
  tend = rep("Bolsonaro",length(inst_bols))
),
data.frame(
  inst.x = inst_neutral,
  tend = rep("Neutral",length(inst_neutral))
))

db_tmp0.b |> 
  group_by(inst.x) |> 
  summarise(Dev_lower, MD_pct, Dev_upper, RMSE_pct) |> 
  unique() |> left_join(db_inst,by="inst.x") |> 
  ggplot(aes(x=inst.x))+
  geom_point(aes(y=RMSE_pct),stat = "identity",size=3.5,shape="diamond")+
  geom_point(aes(y=MD_pct))+ #, color=tend))+
  geom_errorbar(aes(ymin=Dev_lower, ymax=Dev_upper, color=tend))+
  labs(x="Institute", y="Mean Deviation", title="Brazilian Elections - Deviation Research Institutes in 2nd Round")+
  scale_color_manual(breaks = c("Lula", "Bolsonaro", "Neutral"),
                     values=c("red", "blue", "grey"))+
  theme(axis.text.x = element_text(angle = 90, vjust = 0))

# Select Target Institutes with lower bias/variance

# Identify sets of institutes
inst_null <- c()

inst_all <- db_tmp0.b |> 
  select(inst.x, MD_pct, SD_pct) |> 
  arrange(MD_pct,SD_pct) |> 
  unique() |> 
  pull(inst.x)

inst_le.2 <- db_tmp0.b |> 
  select(inst.x, MD_pct, SD_pct) |> 
  arrange(MD_pct,SD_pct) |> 
  filter(MD_pct<.02) |> 
  unique() |> 
  pull(inst.x)

inst_le.35 <- db_tmp0.b |> 
  select(inst.x, MD_pct, SD_pct) |> 
  arrange(MD_pct,SD_pct) |> 
  filter(MD_pct<.035) |> 
  unique() |> 
  pull(inst.x)

inst_le.40 <- db_tmp0.b |> 
  select(inst.x, MD_pct, SD_pct) |> 
  arrange(MD_pct,SD_pct) |> 
  filter(MD_pct<.04) |> 
  unique() |> 
  pull(inst.x)

# Select target Institutes
target_inst <- inst_null

```


```{r}
# Calculate bias from 1st round and apply to 2nd round
db_urnas <- db_poll_wrk |> 
  filter(turno==1, inst=="urnas") |> 
  ungroup()

# Select polls from 1st round
db_tmp0.a <- db_poll_wrk |> 
  filter(turno==1, inst!="urnas", newlbl!="Z-Undec", pct > 0.0) |> 
  select(inst,type,name, newlbl,pct)

# Select relevant fields from 'urnas' 
db_tmp0.b <- db_urnas |> 
  group_by(newlbl) |> 
#  select(newlbl, pct) |> 
  summarise(pct = sum(pct))


db_tmp1 <- left_join(db_tmp0.a, db_tmp0.b,by="newlbl")|> 
#  mutate(bias = pct.x-pct.y) |> 
  mutate(bias = pct.y/pct.x) |> # calculate relative bias from 1st round results
  select(inst, type, newlbl, bias) |> 
  ungroup()

db_tmp1 |> group_by(inst, type, newlbl) |> 
  mutate(n=n(),
         bal_bias = bias/sum(bias),
         norm_bias = bal_bias/sum(bal_bias))

#db_tmp |> filter(newlbl=="Bolsonaro",inst=="datafolha") |> 
#  group_by(inst,type) |> 
#  mutate(avg_bias = mean(bias),
#         sd_bias = sd(bias),
#         n_bias = n(),
#         std_bias = (bias-avg_bias)/(sd_bias)) 

db_viespdata <- db_tmp1 |> 
  filter(newlbl %in% c("Bolsonaro", "Lula", "Y-Blank/Null")) |> 
  group_by(inst, type, newlbl) |> 
  mutate(avg_bias=mean(bias),
         sd_bias=sd(bias),
         n_bias = n()) |> 
  select(inst,type,newlbl,avg_bias,sd_bias,n_bias) |> 
  unique() |> 
#  group_by(inst,type) |> 
  pivot_wider(id_cols=inst:type, names_from=newlbl, values_from = avg_bias:n_bias) |> 
  mutate(vbols=avg_bias_Bolsonaro,
         vlula=avg_bias_Lula,
         vnull=`avg_bias_Y-Blank/Null`) |> 
  select(inst,type,vbols, vlula, vnull)


#db_viespdata <- db_tmp1 |> 
#  filter(newlbl %in% c("Bolsonaro", "Lula", "Y-Blank/Null")) |> 
#  group_by(inst, type, newlbl) |> 
#  mutate(avg_bias=mean(bias),
#         sd_bias=sd(bias),
#         n_bias = n(),
#         std_bias = (bias-avg_bias)/(sd_bias)) |> 
#  select(inst,type,newlbl,avg_bias,sd_bias,n_bias,std_bias) |> 
#  unique() |> 
##  group_by(inst,type) |> 
#  pivot_wider(id_cols=inst:type, names_from=newlbl, values_from = avg_bias:std_bias) |> 
#  mutate(vbols=avg_bias_Bolsonaro,
#         vlula=avg_bias_Lula,
#         vnull=`avg_bias_Y-Blank/Null`) |> 
#  select(inst,type,vbols, vlula, vnull)

remove(db_tmp0.a, db_tmp0.b, db_tmp1, db_urnas)

# Apply bias reduction
if (adjust_bias) {
  # Temporary join dataframe
  db_jn <- left_join(db_poll_wrk, db_viespdata)
  
  db_poll_wrk <- db_jn |> 
    group_by(newlbl) |> 
    mutate(pct = ifelse(newlbl=="Bolsonaro",pct*vbols,
                        ifelse(newlbl=="Lula",pct*vlula,
                               ifelse(newlbl=="Y_Blank/Null",pct*vnull,pct))),
           Me = pct,
           Pe = pct*n,
           Ne = Pe,
           Se = pct*(1-pct)*n,
           Mc = (1-pct),
           Pc = (1-pct)*n,
           Nc = Pc,
           Sc = (1-pct)*pct*n,
           y_cat = round(pct*n))
  
  remove(db_jn)
}

```
\section{Elaborate dataframe for processing (both cases)}

```{r, message=FALSE}
# Restrict analysis for Scenario #1
db_work  <- db_poll_wrk %>% 
  filter (seqno==1, turno==target_round) %>% 
  group_by(key, inst, date, newlbl) %>% 
  summarise(y = sum(y_cat)) |> 
  group_by(date, inst) |>
#  filter(newlbl != "Z-Null") |> 
  filter(newlbl != "Z-Undec") |> 
  mutate(pct_val = y/sum(y)) |> 
  ungroup()

paramlbl <- db_work %>% 
  group_by(newlbl) %>%
  summarise() %>% 
  pull(newlbl)
```


```{r}
# Loading ’meta’ package (version 4.0-2).
# 2. Do meta-analysis
start_date <- "2022-10-02"
#start_date = "2022-04-03"
end_date <- tail(db_poll_wrk |> group_by(date) |> summarise() |> pull(),1)

# if (target_inst=="") {
if (length(target_inst)==0) {
  mpL <- metaprop(Ne, n, studlab=key, method = "Inverse", method.ci = "NAsm", 
                  data=db_poll_wrk %>% filter (newlbl=="Lula", seqno==1, turno==2, date >= start_date, date <= end_date))
  if (target_round==1) { 
    mpC <- metaprop(Ne, n, studlab=key, method = "Inverse", method.ci = "NAsm", 
                  data=db_poll_wrk %>% filter (newlbl=="Ciro", seqno==1, date >= start_date, date <= end_date))
  }
  mpB <- metaprop(Ne, n, studlab=key, method = "Inverse", method.ci = "NAsm", 
                  data=db_poll_wrk %>% filter (newlbl=="Bolsonaro", seqno==1, turno==2, date >= start_date, date <= end_date))
  if (target_round==1) {
    mpS <- metaprop(Ne, n, studlab=key, method = "Inverse", method.ci = "NAsm", 
                  data=db_poll_wrk %>% filter (newlbl=="Simone Tebet", seqno==1, date >= start_date, date <= end_date))
  }
} else {
  mpL <- metaprop(Ne, n, studlab=key, method = "Inverse", method.ci = "NAsm", 
                  data=db_poll_wrk %>% filter (newlbl=="Lula", seqno==1, date >= start_date, date <= end_date, inst %in% target_inst))
  if (target_round==1) {
    mpC <- metaprop(Ne, n, studlab=key, method = "Inverse", method.ci = "NAsm", 
                  data=db_poll_wrk %>% filter (newlbl=="Ciro", seqno==1, date >= start_date, date <= end_date, inst %in% target_inst))
  }
  mpB <- metaprop(Ne, n, studlab=key, method = "Inverse", method.ci = "NAsm", 
                  data=db_poll_wrk %>% filter (newlbl=="Bolsonaro", seqno==1, date >= start_date, date <= end_date, inst %in% target_inst))
  if (target_round==1) {
    mpS <- metaprop(Ne, n, studlab=key, method = "Inverse", method.ci = "NAsm", 
                  data=db_poll_wrk %>% filter (newlbl=="Simone Tebet", seqno==1, date >= start_date, date <= end_date, inst %in% target_inst))
  }
}

```

```{r, fig.height=12, fig.width=10}
meta_bolsonaro <- forest(mpB, xlab="Bolsonaro")
if (target_round==1) forest(mpC, xlab="Ciro")
meta_lula <- forest(mpL, xlab="Lula")
if (target_round==1) forest(mpS, xlab="Simone Tebet")
```


```{r}
#db_work %>% ggplot(aes(x=date, y=y, col=newlbl))+
#  geom_line(size = 0.8) + 
#  ggtitle("Evolution") + 
#  xlab("Date") + ylab("% Voters")+
#  theme_bw()
```

```{r}
# Elections 2018
#start_date = "2018-09-10"

db_work_obs <- pivot_wider(db_work, id_cols = c("key","inst","date"), values_from = "y", names_from = "newlbl") %>% 
  arrange(date)
db_work_obs[is.na(db_work_obs)] <- 0

if (length(target_inst)==0) {
  y <- as.integer(unname(as.matrix(db_work_obs %>% filter(date >= start_date, date <= end_date))[,paramlbl]))
} else {
  y <- as.integer(unname(as.matrix(db_work_obs %>% filter(date >= start_date, date <= end_date, inst %in% target_inst))[,paramlbl]))
}

y <- matrix(y,ncol=length(paramlbl),byrow=FALSE)
y_sums <- rowSums(y)
```

STAN - Multinomial

```{r}
#https://vasishth.github.io/bayescogsci/book/modeling-multiple-categorical-responses.html
# Why using target
# https://stackoverflow.com/questions/40289457/stan-using-target-syntax
# https://discourse.mc-stan.org/t/differences-between-normal-and-target-normal-lpdf/3519


m2.2 <- "
data {
  int<lower = 1> N;
  int<lower = 2> K;
  vector[N] N_trials;
  vector[K] alpha;
  array[N, K] int ans;
}
parameters {
  simplex[K] theta;
}
model {
  target += dirichlet_lpdf(theta | alpha); // rep_vector(2, 5));
  for (n in 1:N) {
    target += multinomial_lpmf(ans[n] | theta);
  }
}
generated quantities{
  int pred_ans[K] = multinomial_rng(theta, K);
}"

alpha_mean <- y[1,]
#alpha_mean <- c(7,3,8,1,2,3)
#alpha_mean <- c(3.5,1.5,2,.5,1,1.5)
#alpha_mean <- rep(1,6)

data_mn.2 <-  list(N = dim(y)[1],
                   K = dim(y)[2],
                   N_trials = y_sums,
#                   alpha = rep(3,dim(y)[2]),
                   alpha = alpha_mean,
                   ans = y) 
```

Interpretation of the Alphas in the Dirichlet distribution

https://stats.stackexchange.com/questions/244917/what-exactly-is-the-alpha-in-the-dirichlet-distribution

https://stats.stackexchange.com/questions/145705/can-a-multinomial1-n-1-n-be-characterized-as-a-discretized-dirichlet1


Beta Distribution (uni-dimensional case)
https://stats.stackexchange.com/questions/243878/conjugate-beta-interpretation-of-the-continuous-binomial-signal

https://stats.stackexchange.com/questions/44494/why-is-the-dirichlet-distribution-the-prior-for-the-multinomial-distribution



```{r}
m2.3 <- "
data {
  int<lower = 1> N;
  int<lower = 2> K;
  int<lower = 0> AMax;
//  vector[N] N_trials;
  array[N, K] int ans;
}
parameters {
  vector<lower=0, upper=AMax>[K] alpha;
  simplex[K] theta;
}

model {

  alpha ~ normal(250,40); // (150,30)
  
  target += dirichlet_lpdf(theta | alpha); // rep_vector(2, 5));
  for (n in 1:N) {
    target += multinomial_lpmf(ans[n] | theta);
  }
}
generated quantities{
  int pred_ans[K] = multinomial_rng(theta, K);
}"
AMax_Value <- 380

data_mn.3 <-  list(N = dim(y)[1],
                   K = dim(y)[2],
                   AMax = AMax_Value,
#                   N_trials = y_sums,
                   ans = y)
```


```{r}
#fit_mn.2 <- stan(data = data_mn.2, 
#               model_code = m2.2,
#               iter = 1500,
#               seed = 530, 
#               verbose=TRUE)

fit_mn.3 <- stan(data = data_mn.3, 
               model_code = m2.3,
               iter = 2200,
               seed = 530, 
               verbose=TRUE)

# Select Model
MODEL_SELECTED <- 3
fit_mn <- fit_mn.3

```

```{r}
if (MODEL_SELECTED == 3)
  print(fit_mn, pars = c("alpha"))

print(fit_mn, pars = c("theta"))
print(paramlbl)

```

```{r}
theta <- extract(fit_mn)[["theta"]]
theta_mean <- colMeans(theta)

if (MODEL_SELECTED == 3) {
  alpha <- extract(fit_mn)[["alpha"]]
  alpha_mean <- colMeans(alpha)
}

yrep <- extract(fit_mn)[["pred_ans"]]
#log_lik <- extract(fit_mn)[["target"]]
nsim<- nrow(yrep)
```


```{r}
m1 <- mean(theta[,1]); s1 <- sd(theta[,1])
m2 <- mean(theta[,2]); s2 <- sd(theta[,2])
cat("\n",format(paramlbl[1], digits=10),": mean=",format(m1,digits=3,nsmall=1),"and sd=",format(s1,digits=4,nsmall=2 ))
cat("\n",format(paramlbl[2], digits=10),": mean=",format(m2,digits=3,nsmall=1),"and sd=",format(s2,digits=4,nsmall=2 ))
```


```{r}
#traceplot(fit_mn, pars = "alpha")
```

```{r}
# Elections 2022 1st. Round
if (target_round==1) {
  p1 <- 1
  p2 <- 3
} else {
# Elections 2022 - 2nd Round
  p1 <- 1
  p2 <- 2
}
# Elections 2018
#p1 <- 2
#p2 <- 4

m1 <- mean(theta[,p1])
m2 <- mean(theta[,p2])
b_vs_l <- stan_scat(fit_mn, pars=c(paste0("theta[", c(p1,p2), "]")))
b_vs_l +
  geom_vline(xintercept = m1, colour="blue")+
  geom_hline(yintercept = m2, colour="red")+
  xlab(paramlbl[p1])+ylab(paramlbl[p2])+
  theme_bw()
```


```{r}
stan_hist(fit_mn, pars=c(paste0("theta[",1:3,"]")), bins=30)

if (MODEL_SELECTED == 3)
  stan_hist(fit_mn, pars=c(paste0("alpha[",1:3,"]")), bins=30)
```

```{r}
if (MODEL_SELECTED == 3)
  stan_dens(fit_mn, pars = "alpha")
```


```{r}
stan_dens(fit_mn, pars = "theta")
```

```{r, warning=FALSE}
panel.cor <- function(x, y, digits = 2, prefix = "", cex.cor, ...)
{
    par(usr = c(0, 1, 0, 1))
    r <- abs(cor(x, y))
    txt <- format(c(r, 0.123456789), digits = digits)[1]
    txt <- paste0(prefix, txt)
    if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
    text(0.5, 0.5, txt, cex = cex.cor * r)
}
pairs(fit_mn, pars = c("theta"),lower.panel = panel.smooth, upper.panel = panel.cor,
      labels = paramlbl, gap=0, row1attop=FALSE)
```

```{r}
stan_rhat(fit_mn, bins=30)
```

```{r}
samp_info <- stan_diag(fit_mn, info='sample')
```

```{r}
samp_info[[3]]
```


```{r}
stan_mcse(fit_mn, pars="theta", bins=30)
```


```{r}
mcmc_trace(As.mcmc.list(fit_mn, pars="theta"))
```

CALCULATE exact probability using Numeric Integration

```{r}
Fmax_ij <- function (u, i, j, alpha, betta) {
  p <- 1.0
  for (k in c(1:(length(alpha)-1))[-c(i,j)]){
    p <- p*pgamma(u, alpha[k], betta)
  }
  #cat("\n\nFMax -> p=",p," c()=",c(1:(length(alpha)-1))[-c(i,j)]," alpha=",alpha," betta=",betta)
  return (p)
}

fmin_ij <- function (u, i, j, alpha, betta) {
  p1 <- dgamma(u,alpha[i],betta)*(1-pgamma(u,alpha[j],betta))
  p2 <- dgamma(u,alpha[j],betta)*(1-pgamma(u,alpha[i],betta))
  #cat("\nfmin -> p1=",p1,"/ p2=",p2," alpha=",alpha," betta=",betta)
  return (p1+p2)
}

Fsum_ij <- function (u, i, alpha, betta) {
  #cat("\n\n[Call]Fsum_ij -> u=",u,"/ i=",i," alpha=",alpha," betta=",betta," sum=",sum(alpha[-c(i,length(alpha))]))
  #cat("\n--> return value=",pgamma(u, sum(alpha[-c(i,length(alpha))]), betta))
  return(pgamma(u, sum(alpha[-c(i,length(alpha))]), betta))
}

fsum_ij <- function (u, i, alpha, betta) {
  return(dgamma(u, sum(alpha[-c(i,length(alpha))]), betta))
}

gammasum <- function (u, i, alpha, betta) {
  #cat("\n\n[Call]gammasum -> u=",u,"/ i=",i," alpha=",alpha," betta=",betta)
  #cat("\n--> dgamma=",dgamma(u, alpha[i], betta))
  return (Fsum_ij(u, i, alpha, betta) * dgamma(u, alpha[i], betta))
}

gamma_ij <- function(u, i, j, alpha, betta) {
#  cat("\ngamma_ij -> u=",u,"/ (i,j)=(",i,",",j,") alpha=",alpha," betta=",betta,"\n\n")
  return(pgamma(u, alpha[j], betta)*dgamma(u, alpha[i], betta))
}

ddelta_ij <- function (u, i, j, alpha, betta) {
  return (Fmax_ij(u, i, j, alpha, betta) * fmin_ij(u, i, j, alpha, betta))
}
```


```{r}
# Iterative process to calculate the probabilities
# Probability of C1 winning in the first round

```

RUN SCenarios based on STAN Model

\subsection{Probabilities of Round 1}

```{r}
# Scenarios Setup
if (MODEL_SELECTED == 3) {
  alph <- alpha_mean
} else {
  alph <- c(7.32,2.29,7.78,1.92,1.24,2.21)
}

beth <- 1.0
lim_sup <- 20

#2022
c1 <- 1
c2 <- 3

# Calculate the probability of exact candidates c1 and c2 pass to 2nd round
P.c1c2 <- MASS::area(ddelta_ij, a=0, b=lim_sup, c1, c2, alph, beth, 
                   fa=0, fb=ddelta_ij(lim_sup, c1, c2, alph, beth),
                   limit = 10, eps = 1e-05)

# Calculate the probability of candidate c1 pass to 2nd round
P2ndround <- 0.0
for (k in c(1:(length(alph)-1))[-c(c1)]) {
  # Probability of Candidates c1 and Candidate k pass 1st. round 
  P1.ij <- MASS::area(ddelta_ij, a=0, b=lim_sup, c1, k, alph, beth, 
                   fa=0, fb=ddelta_ij(lim_sup, c1, k, alph, beth),
                   limit = 10, eps = 1e-05)
  
  # Probability of Candidates c1 overcome Candidate k in 2nd. round 
  P3.ij <- MASS::area(gamma_ij, a=0, b=lim_sup, c1, k, alph, beth, 
                 fa=0, fb=gamma_ij(lim_sup, c1, k, alph, beth),
                 limit = 10, eps = 1e-05)
  P2ndround <- P2ndround + P1.ij * P3.ij

}

# Probability of candidate c1 win in 1st round
P2.i <- MASS::area(gammasum, a=0, b=lim_sup, c1, alph, beth, 
                 fa=0, fb=gammasum(lim_sup, c1, alph, beth),
                 limit = 10, eps = 1e-05)

# Probability of None wins in 1st round
SumP2 <- 0.0
for (k in c(1:(length(alph)-1))) {
  # Probability of Candidates k wins in 1st. round
  P.ck <- MASS::area(gammasum, a=0, b=lim_sup, k, alph, beth, 
                 fa=0, fb=gammasum(lim_sup, k, alph, beth),
                 limit = 10, eps = 1e-05)
  cat("\nProbability of candidate",paramlbl[k],"win in 1st round", P.ck,"\n")
  SumP2 <- SumP2 + P.ck

}

# Probability of candidate c2 win in 1st round
#P2.j <- MASS::area(gammasum, a=0, b=lim_sup, c2, alph, beth, 
#                 fa=0, fb=gammasum(lim_sup, c2, alph, beth),
#                 limit = 10, eps = 1e-05)

# Probability of candidate c1 win elections
totProb.ij <- P2.i + (1-SumP2) * P2ndround  # P1.ij * P3.ij

# Show Results of projected Scenario
cat("\n==> Probability of NO CANDIDATE is elected in 1st round ", (1-SumP2))
cat("\n\nProbability of scenario with candidate",paramlbl[c1],"pass 1st round", P2ndround)
cat("\nProbability of candidate",paramlbl[c1],"and",paramlbl[c2],"are the most voted in 1st Round", P.c1c2)
# cat("\nProbability of candidate ",paramlbl[c1]," win in 1st round", P2.i)
# cat("\nProbability of candidate ",paramlbl[c2]," win in 1st round", P2.j)
# cat("\nProbability of candidate ",paramlbl[c1]," overcome candidate ",paramlbl[c2]," in 2nd round", P3.ij)
cat("\nIn this scenario, the probability of candidate",paramlbl[c1],"win Elections is", totProb.ij)
```
All possible scenarios in round 1

```{r}
for (i in 1:5) {
  cat("\nScenarios with w/ C1:",toupper(paramlbl[i]))
  S <- 0.0
  for (j in c(1:5)[-i]) {
    P.ij <- MASS::area(ddelta_ij, a=0, b=lim_sup, i, j, alph, beth, 
                   fa=0, fb=ddelta_ij(lim_sup, i, j, alph, beth),
                   limit = 10, eps = 1e-05)
    cat("\n... and ",paramlbl[j],"are the most voted in 1st Round", 
        format(P.ij, width = 8, digits = 2, 
             nsmall = 6, justify = "right"))
    S <- S + P.ij
  }
  cat("\nTotal Probability of",toupper(paramlbl[i]), " -> ",
      format(round(S, digits=4), width = 6, digits = 2, 
             nsmall = 4, justify = "right"))
  cat("\n---------------------------\n")
}
```

\subsection{Probabilities of Round 2}

```{r}
# Scenarios Setup
if (MODEL_SELECTED == 3) {
  alph <- alpha_mean
} else {
  alph <- c(7.32,2.29,7.78,1.92,1.24,2.21)
}

beth <- 1.0
lim_sup <- AMax_Value

#2022
c1 <- 1
c2 <- 2

# Calculate the probability of candidate c1 pass to 2nd round
#PWin2ndround <- MASS::area(gamma_ij, a=0, b=lim_sup, c1, c2, alph, beth, 
#                 fa=0, fb=gamma_ij(lim_sup, c1, c2, alph, beth),
#                 limit = 10, eps = 1e-05)
#MASS::area(gamma_ij, a=0, b=lim_sup, c1, c2, alph, beth, 
#                 fa=0, fb=gamma_ij(lim_sup, c1, c2, alph, beth),
#                 limit = 10, eps = 1e-05)

#PC1Win2ndround <- integrate(gamma_ij,lower = 0, upper = lim_sup, i=c1, j=c2, alpha=alph, betta=beth)$value
#PC2Win2ndround <- integrate(gamma_ij,lower = 0, upper = lim_sup, i=c2, j=c1, alpha=alph, betta=beth)$value

PC1Win2ndround <- integrate(gammasum,lower = 0, upper = lim_sup, i=c1, alpha=alph, betta=beth)$value
PC2Win2ndround <- integrate(gammasum,lower = 0, upper = lim_sup, i=c2, alpha=alph, betta=beth)$value

# plot(dgamma(seq(0, 1000, by = 1),alph[c1], beth)*pgamma(seq(0, 1000, by = 1),alph[c2], beth))

# Show Results of projected Scenario
cat("\n\nProbability of",paramlbl[c1],"win elections", PC1Win2ndround)
cat("\n\nProbability of",paramlbl[c2],"win elections", PC2Win2ndround)
```


Summary of Researches available

```{r}
db_poll_wrk %>% 
  filter(date>=start_date) |> 
  group_by(regno, inst) %>% 
  distinct(regno) %>% 
  group_by(inst) %>% 
  summarise(n=n()) %>% 
  kbl(booktabs = TRUE, digits = 4,
      caption = "No. of Election Polls by Institute") %>% 
  kable_styling(latex_options = "striped")
```

STAN - Build Database for Inference

```{r}
#INitialization
# Design of Scenarios

if (target_round==1) {
  Scenarios <- data.frame (
    C1 = c(1, 1, 2),
    C2 = c(3, 2, 3)
  )
} else {
  Scenarios <- data.frame (
    C1 = c(1),
    C2 = c(2)
  )
}

# Scenarios 2018
#Scenarios <- data.frame (
#  C1 = c(3, 4, 1, 2),
#  C2 = c(2, 2, 2, 5)
#)

db_iter_stats <- data.frame()

# Prepare
if (length(target_inst)==0) {
  db_iter_wrk <- db_work_obs %>% 
    arrange(date) %>% 
    filter(date >= start_date, date <= end_date)
} else {
  db_iter_wrk <- db_work_obs %>% 
    arrange(date) %>% 
    filter(inst %in% target_inst, date >= start_date, date <= end_date)
}

v_dates <- db_iter_wrk %>% group_by(date) %>% pull(date) %>% unique()

#Initialize model variables
alph <- alpha_mean
beth <- 1.0
#lim_sup <- 20

Model <- 3

```


```{r}
# Run all scenarios
for (ScenIdx in 1:nrow(Scenarios)) {
  
  c1 <- Scenarios$C1[ScenIdx]
  c2 <- Scenarios$C2[ScenIdx]
  
  cat("\nRunning Scenario ", ScenIdx, "with ", paramlbl[c1]," and ",paramlbl[c2])
  
  idx <- 1

  tb_alphas <- matrix(rep(0, length(v_dates)*length(paramlbl)), nrow=length(v_dates), ncol=length(paramlbl))
  Prob_c1c2_pass_2ndRnd <- rep(0, length(v_dates))
  Prob_c1_pass_2ndRnd <- rep(0, length(v_dates))
  Prob_c2_pass_2ndRnd <- rep(0, length(v_dates))
  Prob_c1_Win_1stRnd <- rep(0, length(v_dates))
  Prob_c2_Win_1stRnd <- rep(0, length(v_dates))
  Prob_c1_Win_2ndRnd <- rep(0, length(v_dates))
  Prob_c2_Win_2ndRnd <- rep(0, length(v_dates))
  Prob_None_Wins_1stRnd <- rep(0, length(v_dates))
  Prob_c1_wins_Elections <- rep(0, length(v_dates))
  Prob_c2_wins_Elections <- rep(0, length(v_dates))
  ProbInteg_c1_wins_Elections <- rep(0, length(v_dates))
  ProbInteg_c2_wins_Elections <- rep(0, length(v_dates))
  
  while (idx <= length(v_dates)) { # Process Incremental Dates
    cat(paste0("\nProcessing date ",v_dates[idx],"...\n"))
    y <- as.integer(unname(as.matrix(db_iter_wrk %>% filter(date <= v_dates[idx]))[,paramlbl]))
    y <- matrix(y,ncol=length(paramlbl),byrow=FALSE)
    y_sums <- rowSums(y)
    
    # Input Data for Stan
    #  alpha_mean <- c(7,3,8,1,2,3)
    if (Model == 2) {
      data_iter_mn <-  list(N = dim(y)[1],
                            K = dim(y)[2],
                            N_trials = y_sums,
                            alpha = alpha_mean,
                            ans = y)
      m_code <- m2.2
    }
    else {
      data_iter_mn <-  list(N = dim(y)[1],
                            K = dim(y)[2],
#                            AMax = 10,
                            AMax = AMax_Value,
                            ans = y)
      m_code <- m2.3
    }
    
    # Run Stan Model
    fit_iter_mn <- stan(data = data_iter_mn, 
                        model_code = m_code,
#                        iter = 1500,
                        iter = 2200,
                        seed = 530,
                        refresh = 0)
    
    # Collect STAN results
    theta <- extract(fit_iter_mn)[["theta"]]
    theta_mean <- colMeans(theta)
    
    if (Model == 3) {
      alpha <- extract(fit_iter_mn)[["alpha"]]
      alpha_mean <- colMeans(alpha)
      alph <- alpha_mean
    }
    
    # Calculate Probabilities
    cat("\nCalculating Probabilities of this scenario...")
    if (target_round==1) {
    # Calculate the probability of exact candidates c1 and c2 pass to 2nd round
      P.c1c2 <- MASS::area(ddelta_ij, a=0, b=lim_sup, c1, c2, alph, beth, 
                           fa=0, fb=ddelta_ij(lim_sup, c1, c2, alph, beth),
                           limit = 10, eps = 1e-05)
      # Calculate the probability of candidate c1 pass to 2nd round
      P2ndround_c1 <- 0.0
      for (k in c(1:(length(alph)-1))[-c(c1)]) {
        # Probability of Candidates c1 and Candidate k pass 1st. round 
        P1.ij <- MASS::area(ddelta_ij, a=0, b=lim_sup, c1, k, alph, beth, 
                            fa=0, fb=ddelta_ij(lim_sup, c1, k, alph, beth),
                            limit = 10, eps = 1e-05)
        
        # Probability of Candidates c1 overcome Candidate k in 2nd. round 
        P3.ij <- MASS::area(gamma_ij, a=0, b=lim_sup, c1, k, alph, beth, 
                            fa=0, fb=gamma_ij(lim_sup, c1, k, alph, beth),
                            limit = 10, eps = 1e-05)
        P2ndround_c1 <- P2ndround_c1 + P1.ij * P3.ij
        
      }
      P2ndround_c2 <- 0.0
      for (k in c(1:(length(alph)-1))[-c(c2)]) {
        # Probability of Candidates c2 and Candidate k pass 1st. round 
        P1.ji <- MASS::area(ddelta_ij, a=0, b=lim_sup, c2, k, alph, beth, 
                            fa=0, fb=ddelta_ij(lim_sup, c2, k, alph, beth),
                            limit = 10, eps = 1e-05)
        
        # Probability of Candidates c1 overcome Candidate k in 2nd. round 
        P3.ji <- MASS::area(gamma_ij, a=0, b=lim_sup, c2, k, alph, beth, 
                            fa=0, fb=gamma_ij(lim_sup, c2, k, alph, beth),
                            limit = 10, eps = 1e-05)
        P2ndround_c2 <- P2ndround_c2 + P1.ji * P3.ji
        
      }
      
      # Probability of candidate c1 win in 1st round
      P2.i <- MASS::area(gammasum, a=0, b=lim_sup, c1, alph, beth, 
                         fa=0, fb=gammasum(lim_sup, c1, alph, beth),
                         limit = 10, eps = 1e-05)
      
      # Probability of candidate c2 win in 1st round
      P2.j <- MASS::area(gammasum, a=0, b=lim_sup, c2, alph, beth, 
                         fa=0, fb=gammasum(lim_sup, c2, alph, beth),
                         limit = 10, eps = 1e-05)
      
      # Probability of None wins in 1st round
      SumP2 <- 0.0
      for (k in c(1:(length(alph)-1))) {
        # Probability of Candidates k wins in 1st. round
        P.ck <- MASS::area(gammasum, a=0, b=lim_sup, k, alph, beth, 
                           fa=0, fb=gammasum(lim_sup, k, alph, beth),
                           limit = 10, eps = 1e-05)
        #    cat("\nProbability of candidate",paramlbl[k],"win in 1st round", P.ck,"\n")
        SumP2 <- SumP2 + P.ck
        
      }
      # Probability of candidate c1 win elections
      totProb.ij <- P2.i + (1-SumP2) * P2ndround_c1  # P1.ij * P3.ij  
      
      # Probability of candidate c1 win elections
      totProb.ji <- P2.j + (1-SumP2) * P2ndround_c2  # P1.ij * P3.ij
    } else {
#      P2ndround_c1 <- 0.0
#      for (k in c(1:(length(alph)-1))[-c(c1)]) {
#        # Probability of Candidates c1 and Candidate k pass 1st. round 
#        P1.ij <- MASS::area(ddelta_ij, a=0, b=lim_sup, c1, k, alph, beth, 
#                            fa=0, fb=ddelta_ij(lim_sup, c1, k, alph, beth),
#                            limit = 10, eps = 1e-05)
#        
#        # Probability of Candidates c1 overcome Candidate k in 2nd. round 
#        P3.ij <- MASS::area(gamma_ij, a=0, b=lim_sup, c1, k, alph, beth, 
#                            fa=0, fb=gamma_ij(lim_sup, c1, k, alph, beth),
#                            limit = 10, eps = 1e-05)
#        P2ndround_c1 <- P2ndround_c1 + P1.ij * P3.ij
#        
#      }      
#      P2ndround_c2 <- 0.0
#      for (k in c(1:(length(alph)-1))[-c(c2)]) {
#        # Probability of Candidates c2 and Candidate k pass 1st. round 
#        P1.ji <- MASS::area(ddelta_ij, a=0, b=lim_sup, c2, k, alph, beth, 
#                            fa=0, fb=ddelta_ij(lim_sup, c2, k, alph, beth),
#                            limit = 10, eps = 1e-05)
#        
#        # Probability of Candidates c1 overcome Candidate k in 2nd. round 
#        P3.ji <- MASS::area(gamma_ij, a=0, b=lim_sup, c2, k, alph, beth, 
#                            fa=0, fb=gamma_ij(lim_sup, c2, k, alph, beth),
#                            limit = 10, eps = 1e-05)
#        P2ndround_c2 <- P2ndround_c2 + P1.ji * P3.ji
#        
#      }
#      # Probability of candidate c1 win in 1st round
#      P2.i <- MASS::area(gammasum, a=0, b=lim_sup, c1, alph, beth, 
#                         fa=0, fb=gammasum(lim_sup, c1, alph, beth),
#                         limit = 10, eps = 1e-05)
#      
#      # Probability of candidate c2 win in 1st round
#      P2.j <- MASS::area(gammasum, a=0, b=lim_sup, c2, alph, beth, 
#                         fa=0, fb=gammasum(lim_sup, c2, alph, beth),
#                         limit = 10, eps = 1e-05)
#      
#      # Probability of None wins in 1st round
#      SumP2 <- 0.0
#      for (k in c(1:(length(alph)-1))) {
#        # Probability of Candidates k wins in 1st. round
#        P.ck <- MASS::area(gammasum, a=0, b=lim_sup, k, alph, beth, 
#                           fa=0, fb=gammasum(lim_sup, k, alph, beth),
#                           limit = 10, eps = 1e-05)
#        #    cat("\nProbability of candidate",paramlbl[k],"win in 1st round", P.ck,"\n")
#        SumP2 <- SumP2 + P.ck
#        
#      }
#      # Probability of candidate c1 win elections
#      totProb.ij <- P2.i + (1-SumP2) * P2ndround_c1  # P1.ij * P3.ij  
#      
#      # Probability of candidate c1 win elections
#      totProb.ji <- P2.j + (1-SumP2) * P2ndround_c2  # P1.ij * P3.ij
#      
      PC1Win2ndround <- integrate(gammasum,lower = 0, upper = lim_sup, i=c1, alpha=alph, betta=beth)$value
      PC2Win2ndround <- integrate(gammasum,lower = 0, upper = lim_sup, i=c2, alpha=alph, betta=beth)$value

    }
    
    cat("\nStoring data...")
    
    #Store Probabilities
    if (target_round==1) {
      tb_alphas[idx,] <- alph
      Prob_c1c2_pass_2ndRnd[idx] <- P.c1c2
      Prob_c1_pass_2ndRnd[idx] <- P2ndround_c1
      Prob_c2_pass_2ndRnd[idx] <- P2ndround_c2
      Prob_c1_Win_1stRnd[idx] <- P2.i
      Prob_c2_Win_1stRnd[idx] <- P2.j
      Prob_None_Wins_1stRnd[idx] <- (1 - SumP2)
      Prob_c1_wins_Elections[idx] <- totProb.ij
      Prob_c2_wins_Elections[idx] <- totProb.ji
    } else {
#      Prob_c1_Win_2ndRnd[idx] <- P2.i
#      Prob_c2_Win_2ndRnd[idx] <- P2.j
#      Prob_c1_wins_Elections[idx] <- totProb.ij
#      Prob_c2_wins_Elections[idx] <- totProb.ji
      ProbInteg_c1_wins_Elections[idx] <- PC1Win2ndround
      ProbInteg_c2_wins_Elections[idx] <- PC2Win2ndround
    }
    
    idx <- idx + 1
    
  }

  if (target_round==1) {
    db_iter_stats <- rbind(db_iter_stats, data.frame (
      scenario = ScenIdx,
      c1 = rep(c1, length(v_dates)),
      c2 = rep(c2, length(v_dates)),
      date = v_dates,
      alphas = tb_alphas,
      Prob_c1c2_pass_2ndRnd = Prob_c1c2_pass_2ndRnd,
      Prob_c1_pass_2ndRnd = Prob_c1_pass_2ndRnd,
      Prob_c2_pass_2ndRnd = Prob_c2_pass_2ndRnd,
      Prob_c1_Win_1stRnd = Prob_c1_Win_1stRnd,
      Prob_c2_Win_1stRnd = Prob_c2_Win_1stRnd,
      Prob_None_Wins_1stRnd = Prob_None_Wins_1stRnd,
      Prob_c1_wins_Elections = Prob_c1_wins_Elections,
      Prob_c2_wins_Elections = Prob_c2_wins_Elections))
  } else {
    db_iter_stats <- rbind(db_iter_stats, data.frame (
      scenario = ScenIdx,
      c1 = rep(c1, length(v_dates)),
      c2 = rep(c2, length(v_dates)),
      date = v_dates,
      alphas = tb_alphas,
#      Prob_c1_Win_2ndRnd = Prob_c1_Win_2ndRnd,
#      Prob_c2_Win_2ndRnd = Prob_c2_Win_2ndRnd,
#      Prob_c1_wins_Elections = Prob_c1_wins_Elections,
#      Prob_c2_wins_Elections = Prob_c2_wins_Elections,
      ProbInteg_c1_wins_Elections <- ProbInteg_c1_wins_Elections,
      ProbInteg_c2_wins_Elections <- ProbInteg_c2_wins_Elections))
  }

}

```

Posterior simulation

```{r}
# Probability of candidates c1=1 and c2=3 pass to 2nd round

v_dates <- db_iter_wrk %>% group_by(date) %>% pull(date) # %>% unique()
y <- as.integer(unname(as.matrix(db_iter_wrk %>% filter(date <= tail(v_dates,n=1)))[,paramlbl]))
y <- matrix(y,ncol=length(paramlbl),byrow=FALSE)

# Calculus of probability of each candidate by simulation of Posterior Dirichlet
N <- 1000

sim_dir <- array(rep(0, nrow(y)*N*length(paramlbl)), dim=c(nrow(y),N,length(paramlbl)))
theta_CI <- list(
  upper = array(rep(0,nrow(y)*length(paramlbl)),dim=c(nrow(y),length(paramlbl))),
  lower = array(rep(0,nrow(y)*length(paramlbl)),dim=c(nrow(y),length(paramlbl)))
)

theta_hist <- array(rep(0,nrow(y)*length(paramlbl)),dim=c(nrow(y),length(paramlbl)))

sim_dir[1,,] <- rdirichlet(N, alpha=(y[1,]+rep(1,length(paramlbl))))
theta_hist[1,] <- colMeans(sim_dir[1,,])
theta_CI$upper[1,] <- theta_hist[1,]+qnorm(.975)*(apply(sim_dir[1,,],2,sd)/sqrt(N))
theta_CI$lower[1,] <- theta_hist[1,]-qnorm(.975)*(apply(sim_dir[1,,],2,sd)/sqrt(N))

for (i in 2:nrow(y)) {
  sim_dir[i,,] <- rdirichlet(N, alpha=(y[i,]+colMeans(sim_dir[i-1,,])*sum(y[i-1,])))
  theta_hist[i,] <- colMeans(sim_dir[i,,])
  theta_CI$upper[i,] <- theta_hist[i,]+qnorm(.975)*(apply(sim_dir[i,,],2,sd)/sqrt(N))
  theta_CI$lower[i,] <- theta_hist[i,]-qnorm(.975)*(apply(sim_dir[i,,],2,sd)/sqrt(N))
}

matplot(theta_hist[,1:2], type = c("b"), pch=1, col = 1:4) #plot
legend("topleft", legend = paramlbl[1:4], col=1:4, pch=1) # optional legend

df <- data.frame()
for (j in 1:3) {
  df <- rbind(df, 
              data.frame(
                date = v_dates,
                cand = paramlbl[j],
                sup = theta_CI$upper[,j],
                mid = theta_hist[,j],
                inf = theta_CI$lower[,j])
  )
}
ggplot(df, aes(x=date)) +
  geom_line(aes(y=mid, color = cand), size=.8)+
  geom_point(aes(y=mid, color = cand), size=3) +
  xlab("Date")+ylab("Pct. Votes")+
  scale_color_manual(breaks = c("Lula", "Bolsonaro", "Y-Blank/Null"),
                     values=c("red", "blue", "grey"))+
  theme_bw()

```

... using MCMC for simulations

```{r}
# Calculus of probability of each candidate by simulation of Posterior Dirichlet
N <- 1000

sim_dir <- array(rep(0, nrow(y)*N*length(paramlbl)), dim=c(nrow(y),N,length(paramlbl)))
theta_hist <- array(rep(0,nrow(y)*length(paramlbl)),dim=c(nrow(y),length(paramlbl)))
theta_CI <- list(
  upper = array(rep(0,nrow(y)*length(paramlbl)),dim=c(nrow(y),length(paramlbl))),
  lower = array(rep(0,nrow(y)*length(paramlbl)),dim=c(nrow(y),length(paramlbl)))
)

sim_dir[1,,] <- MCMCpack::MCmultinomdirichlet(y[1,], alpha0 = (y[1,]+rep(1,length(paramlbl))), mc=N)
theta_hist[1,] <- colMeans(sim_dir[1,,])
theta_CI$upper[1,] <- theta_hist[1,]+qnorm(.975)*(apply(sim_dir[1,,],2,sd)/sqrt(N))
theta_CI$lower[1,] <- theta_hist[1,]-qnorm(.975)*(apply(sim_dir[1,,],2,sd)/sqrt(N))


for (i in 2:nrow(y)) {
  sim_dir[i,,] <- MCMCpack::MCmultinomdirichlet(y[i,], alpha0 = (y[i,]+colMeans(sim_dir[i-1,,])*sum(y[i-1,])), mc=N)
  theta_hist[i,] <- colMeans(sim_dir[i,,])
  theta_CI$upper[i,] <- theta_hist[i,]+qnorm(.975)*(apply(sim_dir[i,,],2,sd)/sqrt(N))
  theta_CI$lower[i,] <- theta_hist[i,]-qnorm(.975)*(apply(sim_dir[i,,],2,sd)/sqrt(N))
}

matplot(theta_hist[,1:2], type = c("b"), pch=1, col = 1:4) #plot
legend("topleft", legend = paramlbl[1:4], col=1:4, pch=1) # optional legend

for (j in 1:2) {
  df <- data.frame(
    sup = theta_CI$upper[,j],
    mid = theta_hist[,j],
    inf = theta_CI$lower[,j]
  )
  p <- ggplot(df, aes(x=v_dates)) +
    geom_line(aes(y=mid),color="black")+
    geom_point(aes(y=mid),color="black") +
    geom_errorbar(aes(ymin=inf, ymax=sup), width=.2)+
    xlab("Date")+ylab(paramlbl[j])+
    theme_bw()
  print(p)
}

df <- data.frame()
for (j in 1:3) {
  df <- rbind(df, 
              data.frame(
                date = v_dates,
                cand = paramlbl[j],
                sup = theta_CI$upper[,j],
                mid = theta_hist[,j],
                inf = theta_CI$lower[,j])
  )
}
ggplot(df, aes(x=date)) +
  geom_line(aes(y=mid, color = cand), size=.8)+
  geom_point(aes(y=mid, color = cand), size=3) +
  xlab("Date")+ylab("Pct. Votes")+
  scale_color_manual(breaks = c("Lula", "Bolsonaro", "Y-Blank/Null"),
                     values=c("red", "blue", "grey"))+
  theme_bw()
```

... using Integration

```{r}
alph <- (y+colMeans(sim_dir[i-1,,])*sum(y[i-1,]))
sim_dir[1,,] <- rdirichlet(N, alpha=(y[1,]+rep(1,length(paramlbl))))
theta_hist[1,] <- colMeans(sim_dir[1,,])
theta_CI$upper[1,] <- theta_hist[1,]+qnorm(.975)*(apply(sim_dir[1,,],2,sd)/sqrt(N))
theta_CI$lower[1,] <- theta_hist[1,]-qnorm(.975)*(apply(sim_dir[1,,],2,sd)/sqrt(N))

for (i in 2:nrow(y)) {
  sim_dir[i,,] <- rdirichlet(N, alpha=(y[i,]+colMeans(sim_dir[i-1,,])*sum(y[i-1,])))
  theta_hist[i,] <- colMeans(sim_dir[i,,])
  theta_CI$upper[i,] <- theta_hist[i,]+qnorm(.975)*(apply(sim_dir[i,,],2,sd)/sqrt(N))
  theta_CI$lower[i,] <- theta_hist[i,]-qnorm(.975)*(apply(sim_dir[i,,],2,sd)/sqrt(N))
}

```


Print Joint Scenarios

```{r}
db_iter_stats %>% 
  mutate(pair = paste0(paramlbl[c1],"-",paramlbl[c2])) %>%
  select(pair, date, Prob_c1c2_pass_2ndRnd) %>% 
  ggplot(aes(x=date, y=Prob_c1c2_pass_2ndRnd))+
  geom_point(aes(colour=pair), size=2.8) +
  geom_line(aes(colour=pair), size=0.8) +
  ggtitle(paste0("Probability of 2nd. round with these candidates - ",target_inst))+
  theme_bw()

```


Print Detailed Scenarios

```{r}
# Plot Scenario
pltScenario <- function (idx) {
  
  Q <- list()
  
  # Auxiliary db
  db_plt_wrk <- db_iter_stats %>% 
    filter(scenario == idx) 
  
  Q[[1]] <- db_plt_wrk %>% 
    ggplot(aes(x=date))+
    geom_line(aes(y=Prob_c1_pass_2ndRnd), size=0.8, colour="blue") +
    geom_point(aes(y=Prob_c1_pass_2ndRnd),size=2.4, colour="blue", shape="diamond") +
    ggtitle(paste0("Probability of candidate ",
                   paramlbl[db_plt_wrk$c1[1]]," pass to 2nd round"))+
    xlab(paste0("Date - Inst. ", target_inst)) +
    scale_color_manual(breaks = c("Lula", "Bolsonaro", "Y-Blank/Null"),
                       values=c("red", "blue", "grey"))+
    theme_bw()
  
  Q[[2]] <- db_plt_wrk %>% 
    ggplot(aes(x=date))+
    geom_line(aes(y=Prob_c2_pass_2ndRnd), size=0.8, colour="red") +
    geom_point(aes(y=Prob_c2_pass_2ndRnd),size=2.4, colour="red", shape="diamond") +
    ggtitle(paste0("Probability of candidate ",
                   paramlbl[db_plt_wrk$c2[1]]," pass to 2nd round"))+
    xlab(paste0("Date - Inst. ", target_inst)) +
    scale_color_manual(breaks = c("Lula", "Bolsonaro", "Y-Blank/Null"),
                       values=c("red", "blue", "grey"))+
    theme_bw()
  
  Q[[3]] <- db_plt_wrk %>% 
    ggplot(aes(x=date))+
    geom_line(aes(y=Prob_c1_wins_Elections), size=0.8, colour="blue") +
    geom_line(aes(y=Prob_c2_wins_Elections), size=0.8, colour="red") +
    geom_point(aes(y=Prob_c1_wins_Elections),size=2.4, colour="blue") +
    geom_point(aes(y=Prob_c2_wins_Elections),size=2.4, colour="red") +
    ggtitle(paste0("Probability of candidates ",
                   paramlbl[db_plt_wrk$c1[1]]," and ",paramlbl[db_plt_wrk$c2[1]]," win the elections"))+
    xlab(paste0("Date - Inst. ", target_inst)) +
    scale_color_manual(breaks = c("Lula", "Bolsonaro", "Y-Blank/Null"),
                       values=c("red", "blue", "grey"))+
    theme_bw()
  
  Q[[4]] <- db_plt_wrk %>% 
    ggplot(aes(x=date))+
    geom_line(aes(y=Prob_c1_Win_1stRnd), size=0.8, colour="blue") +
    geom_line(aes(y=Prob_c2_Win_1stRnd), size=0.8, colour="red") +
    geom_point(aes(y=Prob_c1_Win_1stRnd),size=2.4, colour="blue") +
    geom_point(aes(y=Prob_c2_Win_1stRnd),size=2.4, colour="red") +
    ggtitle(paste0("Probability of candidates ",
                   paramlbl[db_plt_wrk$c1[1]]," and ",paramlbl[db_plt_wrk$c2[1]]," win in 1st. Round"))+
    xlab(paste0("Date - Inst. ", target_inst)) +
    scale_color_manual(breaks = c("Lula", "Bolsonaro", "Y-Blank/Null"),
                       values=c("red", "blue", "grey"))+
    theme_bw()
  
  Q[[5]] <- db_plt_wrk %>% 
    ggplot(aes(x=date))+
    geom_line(aes(y=Prob_c1c2_pass_2ndRnd), size=0.8, colour="black") +
    geom_point(aes(y=Prob_c1c2_pass_2ndRnd),size=2.4) +
    ggtitle(paste0("Probability of candidates ",
                   paramlbl[db_plt_wrk$c1[1]]," and ",paramlbl[db_plt_wrk$c2[1]]," are the most voted in 1st. round"))+
    xlab(paste0("Date - Inst. ", target_inst)) +
    scale_color_manual(breaks = c("Lula", "Bolsonaro", "Y-Blank/Null"),
                       values=c("red", "blue", "grey"))+
    theme_bw()
  
  Q[[6]] <- db_plt_wrk %>% 
    ggplot(aes(x=date))+
    geom_line(aes(y=Prob_None_Wins_1stRnd), size=0.8, colour="black") +
    geom_point(aes(y=Prob_None_Wins_1stRnd),size=2.4) +
    ggtitle(paste0("Probability of no candidate wins in 1st. round"))+
    xlab(paste0("Date - Inst. ", target_inst)) +
    scale_color_manual(breaks = c("Lula", "Bolsonaro", "Y-Blank/Null"),
                       values=c("red", "blue", "grey"))+
    theme_bw()
  
  Q[[7]] <- db_plt_wrk %>% 
    ggplot(aes(x=date))+
    geom_line(aes(y=ProbInteg_c1_wins_Elections), size=0.8, colour="blue") +
    geom_line(aes(y=ProbInteg_c2_wins_Elections), size=0.8, colour="red") +
    geom_point(aes(y=ProbInteg_c1_wins_Elections),size=2.4, colour="blue") +
    geom_point(aes(y=ProbInteg_c2_wins_Elections),size=2.4, colour="red") +
    ggtitle(paste0("Probability of candidates ",
                   paramlbl[db_plt_wrk$c1[1]]," and ",paramlbl[db_plt_wrk$c2[1]]," win elections"))+
    xlab(paste0("Date - Inst. ", target_inst)) +
    scale_color_manual(breaks = c("Lula", "Bolsonaro", "Y-Blank/Null"),
                       values=c("red", "blue", "grey"))+
    theme_bw()
  
  return(Q)
}

```


```{r}
db_iter_stats %>% 
  filter(scenario == 1) %>% 
  ggplot(aes(x=date))+
  geom_line(aes(y=ProbInteg_c1_wins_Elections), size=0.8, colour="blue") +
  geom_line(aes(y=ProbInteg_c2_wins_Elections), size=0.8, colour="red") +
  geom_point(aes(y=ProbInteg_c1_wins_Elections),size=2.4, colour="blue") +
  geom_point(aes(y=ProbInteg_c2_wins_Elections),size=2.4, colour="red") +
  ggtitle(paste0("Probability of candidates ",
                 paramlbl[db_iter_stats$c1[1]]," and ",paramlbl[db_iter_stats$c2[1]]," win elections"))+
  xlab(paste0("Date - Inst. ", target_inst)) +
  scale_color_manual(breaks = c("Lula", "Bolsonaro", "Y-Blank/Null"),
                     values=c("red", "blue", "grey"))+
  #    geom_text(hjust=0, vjust=0)+
  theme_bw()
```


```{r, fig.height=5, fig.width=6.5}
# Q <- pltScenario(1)

# Scenario 2018
Q <- pltScenario(1)

if (target_round==1) {
  Q_list <- c(1:6)
} else {
 Q_list <- c(7) 
}

for (i in Q_list)
  print(Q[[i]])
```

Stan Compatibility Errors (workaround) - RUN ONCE!

```{r}
#https://discourse.mc-stan.org/t/rstan-error-in-compilecode-f-code-language-language-verbose-verbose/28007/8
#remove.packages(c("StanHeaders", "rstan"))
#install.packages("StanHeaders", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
#install.packages("rstan", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
```


Stan Example (logit)

```{r}
#https://eleafeit.com/posts/2021-05-23-parameterization-of-multinomial-logit-models-in-stan/
```


```{r}
library(bayesplot) 
library(gtools) # rdirchlet
#rstan_options(auto_write=TRUE) # writes a compiled Stan program to the disk to avoid recompiling
#options(mc.cores = parallel::detectCores()) # uses multiple cores for stan
```

```{r}
#posterior <- as.matrix(fit_mn)
#mcmc_areas(posterior,
#           pars = c(paste0("theta[",c(1,3),"]")),
#           prob = 0.8)
#ppc_dens_overlay(y = fit_mn$y,
#                 yrep = posterior_predict(fit_mn, draws = 50))
```

```{r}
set.seed(9)
X <- 1000*rt(1000,3)
mean(X)
hist(X)
sd(X)
plot(density(X))

require(graphics)

1 - pt(1:5, df = 3)
qt(.975, df = c(1:10,20,50,100,1000))

tt <- seq(0, 10, length.out = 21)
ncp <- seq(0, 6, length.out = 31)
ptn <- outer(tt, ncp, function(t, d) pt(t, df = 3, ncp = d))
t.tit <- "Non-central t - Probabilities"
image(tt, ncp, ptn, zlim = c(0,1), main = t.tit)
persp(tt, ncp, ptn, zlim = 0:1, r = 2, phi = 20, theta = 200, main = t.tit,
      xlab = "t", ylab = "non-centrality parameter",
      zlab = "Pr(T <= t)")

plot(function(x) dt(x, df = 3, ncp = 2), -3, 11, ylim = c(0, 0.32),
     main = "Non-central t - Density", yaxs = "i")
```


```{r}
set.seed(853)

rep(1:5, times=3)

newborn_weight <-
  tibble(
    weight =
      rep(
        x = rnorm(
          n = 1000,
          mean = 3.5,
          sd = 0.5
        ),
        times = 3
      ),
    measurement = c(
      rep("Actual", 1000),
      rep("Censored", 1000),
      rep("Truncated", 1000)
    )
  )

newborn_weight <-
  newborn_weight |>
  mutate(
    weight = if_else(
      weight <= 2.75 & measurement == "Censored",
      2.75,
      weight
    ),
    weight = if_else(
      weight >= 4.25 & measurement == "Truncated",
      NA_real_,
      weight
    )
  )

newborn_weight |> 
  ggplot(aes(x = weight)) +
  geom_histogram(bins = 50) +
  facet_wrap(vars(measurement)) +
  theme_minimal()

remove(t)

```

```{r}
library(tidyverse)
library(jsonlite)

url_pres_br = "https://resultados.tse.jus.br/oficial/ele2022/544/dados-simplificados/br/br-c0001-e000544-r.json"

pres_br <-  fromJSON(url_pres_br, simplifyDataFrame = TRUE) %>%
  .[["cand"]] %>% 
  tbl_df()
```

8.4.2 Probabilistic Sampling (R. Alexander, Chap 8th)

\subsection{Simple Random Sampling}

```{r}
set.seed(853)

illustrative_sampling <-
  tibble(
    unit = 1:100,
    simple_random_sampling =
      sample(
        x = c("Included", "Not included"),
        size = 100,
        replace = TRUE,
        prob = c(0.2, 0.8)
      )
  )

illustrative_sampling |>
  count(simple_random_sampling)
```

\subsection{Systematic Sampling}

```{r}
set.seed(853)

starting_point <- sample(
  x = c(1:5),
  size = 1
)

illustrative_sampling <-
  illustrative_sampling |>
  mutate(
    systematic_sampling =
      if_else(
        unit %in% seq.int(
          from = starting_point,
          to = 100,
          by = 5
        ),
        "Included",
        "Not included"
      )
  )

illustrative_sampling |>
  count(systematic_sampling)
```

\subsection{Stratified Sampling}

```{r}
set.seed(853)

selected_within_strata <-
  illustrative_sampling |>
  mutate(strata = (unit - 1) %/% 10) |>
  group_by(strata) |>
  slice_sample(n = 2) |>
  pull(unit)

illustrative_sampling <-
  illustrative_sampling |>
  mutate(stratified_sampling = if_else(
    unit %in% selected_within_strata,
    "Included",
    "Not included"
  ))

illustrative_sampling |>
  count(stratified_sampling)
```

\subsection{Cluster Sampling}

```{r}
set.seed(853)

selected_clusters <-
  sample(
    x = c(0:9),
    size = 2
  )

illustrative_sampling <-
  illustrative_sampling |>
  mutate(
    cluster = (unit - 1) %/% 10,
    cluster_sampling = if_else(
      cluster %in% selected_clusters,
      "Included",
      "Not included"
    )
  ) |>
  select(-cluster)

illustrative_sampling |>
  count(cluster_sampling)
```

\subsection{Comparative}

```{r}
new_labels <- c(
  simple_random_sampling = "Simple random sampling",
  systematic_sampling = "Systematic sampling",
  stratified_sampling = "Stratified sampling",
  cluster_sampling = "Cluster sampling"
)

illustrative_sampling_long <-
  illustrative_sampling |>
  pivot_longer(
    cols = c(
      simple_random_sampling,
      systematic_sampling,
      stratified_sampling,
      cluster_sampling
    ),
    names_to = "sampling_method",
    values_to = "in_sample"
  ) |>
  mutate(sampling_method = factor(
    sampling_method,
    levels = c(
      "simple_random_sampling",
      "systematic_sampling",
      "stratified_sampling",
      "cluster_sampling"
    )
  ))

illustrative_sampling_long |>
  filter(in_sample == "Included") |>
  ggplot(aes(x = unit, y = in_sample)) +
  geom_point() +
  facet_wrap(
    vars(sampling_method),
    dir = "v",
    ncol = 1,
    labeller = labeller(sampling_method = new_labels)
  ) +
  theme_minimal() +
  labs(
    x = "Unit",
    y = "Is included in sample"
  ) +
  theme(axis.text.y = element_blank())
```

```{r}
illustrative_sampling_long |>
  filter(in_sample == "Included") |>
  group_by(sampling_method) |>
  summarize(sum_from_sample = sum(unit)) |>
  mutate(scaled_by_five = sum_from_sample * 5) |>
  knitr::kable(
    col.names = c(
      "Sampling method",
      "Sum of sample",
      "Implied population sum"
    ),
    format.args = list(big.mark = ",")
  )
```

\subsection{Estimation}

```{r}
set.seed(853)

sleep <-
  tibble(
    toddler_sleep = sample(x = c(2:14), size = 30, replace = TRUE),
    difference = sample(x = c(0:3), size = 30, replace = TRUE),
    parent_sleep = toddler_sleep - difference
  ) |>
  select(toddler_sleep, parent_sleep, difference)

sleep
```

```{r}
sleep |>
  summarize(
    toddler_sleep_average = mean(toddler_sleep),
    parent_sleep_average = mean(parent_sleep)
  ) |>
  knitr::kable(
    col.names = c("Toddler sleep average", "Parent sleep average"),
    format.args = list(big.mark = ","),
    digits = 2
  )
```

8.4.3 Non-Probability samples

